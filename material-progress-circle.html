<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">

<!--
A Material design circle-multi-progress bar, inspired by Google Fit.

TODO docs

@group material-progress
@element material-progress-bars
@demo demo/index.html
-->
<dom-module id="material-progress-circle">
  <style>
    :host {
      position: relative;
      display: block;
      margin: 8px;
      width: 200px;
      height: 200px;
      opacity: 0;
      transition: opacity 500ms cubic-bezier(0.4, 0.0, 0.2, 1);
      background: var(--material-progress-background-color, transparent);
    }
    :host(.ready) {
      opacity: 1;
    }
    svg {
      position: absolute;
      display: block;
      left: 0; 
      right: 0; 
      height: 100% !important;
      width: 100% !important;
    }
    svg circle.backgroundSvg {
      stroke: var(--material-progress-bars-background-color, rgba(0, 0, 0, 0.04));
    }
    svg circle.barSvg {
      stroke-linecap: var(--material-progress-bar-linecap, round);
    }
    :host([animated]) svg circle.barSvg {
      transition: stroke-dashoffset 850ms cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    #contentContainer {
      position: absolute;
      border-radius: 50%;
      @apply(--layout-vertical);
      @apply(--layout-center-center);
    }
  </style>
  <template>
    <svg id="svg">
      <circle class="backgroundSvg"
          r$="[[_radius]]"
          cx$="[[_cx]]"
          cy$="[[_cy]]"
          fill="transparent"
          stroke-width$="[[barHeight]]" />
    </svg>
    <div id="contentContainer">
      <content></content>
    </div>
  </template>
</dom-module>
<script>
(function() {
  'use strict';
  Polymer({
    is: 'material-progress-circle',

    properties: {
      /**
       * Data to display in the progress bar.
       * Each item describes a new progress bar, and must possess
       * a `value` and a `color` attribute.
       * 
       * Example:
       *
       *     {value: 20, color: '#FF5722'}
       */
      data: {
        type: Array,
        value: function() {
          return [];
        }
      },

      /**
       * Maximum value for the `sum` of the bars' values.
       * 
       * If the `sum` is higher, it will be used as the `max`.
       */
      max: {
        type: Number,
        value: 128,
        observer: '_requestRender'
      },

      /**
       * Sum of all the bars' values.
       */
      sum: {
        type: Number,
        value: 0,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * Height (or thickness) of every progress bar.
       */
      barHeight: {
        type: Number,
        value: 12,
        observer: '_requestRender'
      },

      /**
       * Animate when the size of a bar changes.
       */
      animated: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    },

    behaviors: [
      Polymer.IronResizableBehavior
    ],

   observers: [
      '_requestRender(data.*)'
    ],

    listeners: {
      'iron-resize': '_requestRender'
    },

    /**
     * Render the whole component
     */
    render: function() {
      var _self = this;
      var barsData = JSON.parse(JSON.stringify(this.data || [])).reverse();
      var svg = Polymer.dom(this.$.svg);
      this._setSum(this._computeSum(barsData));
      this._cx = this.clientWidth / 2;
      this._cy = this.clientHeight / 2;
      this._radius = Math.max(0, Math.min(this._cx, this._cy) - this.barHeight / 2);
      this._dasharray = 2 * Math.PI * this._radius;
      
      // Compute each bar's data
      var normalizedMax = Math.max(this.max, this.sum);
      barsData.reduceRight(function(currentSum, bar) {
        bar._sumValue = bar.value + currentSum;
        bar._dashoffset = (1 - bar._sumValue / normalizedMax) * _self._dasharray;
        return bar._sumValue;
      }, 0);

      // Ensure that there is a svg 'circle' element for each bar, flush the Dom and re-render
      if (barsData.length - (svg.children.length - 1) > 0) {
        this._createBars(barsData);
        return;
      }

      // Set the correct attributes to each bar
      var svgChildren = svg.children;
      var currentBar;
      for (var j = 0, barCount = svgChildren.length; j < barCount-1; j++) {
        currentBar = barsData[j] || {};
        this._updateBar(svgChildren[j+1], currentBar._dashoffset, currentBar.color);
      }

      // Set up the size of the inner content
      this._updateContentContainer();

      // Display the element when ready
      this.classList.add('ready');
    },

    /**
     * Create new bars in the DOM, then re-render
     */
    _createBars: function(barsData) {
      var svg = Polymer.dom(this.$.svg);

      // Add missing svg circle(s)
      var currentBar;
      var newCircle;
      for (var i = 0, barCountToAdd = barsData.length - (svg.children.length - 1); i < barCountToAdd; i++) {
        currentBar = barsData[i] || {};
        newCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this._updateBar(newCircle, this._dasharray, currentBar.color);
        svg.appendChild(newCircle);
      }

      // Flush DOM and re-render to allow the css transition
      Polymer.dom.flush();
      this._requestRender();
    },

    /**
     * Request a render when ready
     */
    _requestRender: function() {
      if (typeof this.clientWidth !== 'undefined') {
        this.debounce('render', this.render, 50);
      }
      else {
        this.async(this._requestRender, 50);
      }
    },

    /**
     * Transform attribute for every SVG circle
     */
    _computeTransform: function(_cx, _cy) {
      return 'rotate(-90, ' + _cx + ', ' + _cy + ')';
    },

    /**
     * Compute the real sum off all the 'data.value'
     */
    _computeSum: function(barsData) {
      return barsData.reduce(function(sum, bar) {
        return sum + (bar.value || 0);
      }, 0);
    },

    /**
     * Update all necessary attributes of a bar (SVG circle node)
     */
    _updateBar: function(bar, dashoffset, color) {
      var dashoffsetExists = dashoffset || dashoffset == 0;
      bar.setAttribute('r', this._radius);
      bar.setAttribute('cx', this._cx);
      bar.setAttribute('cy', this._cy);
      if (dashoffsetExists) {
        bar.setAttribute('stroke', color || '#FF5722');
      }
      bar.setAttribute('fill', 'transparent');
      bar.setAttribute('stroke-width', this.barHeight);
      bar.setAttribute('stroke-dasharray', this._dasharray);
      bar.setAttribute('stroke-dashoffset', dashoffsetExists ? dashoffset : this._dasharray);
      bar.setAttribute('transform', this._computeTransform(this._cx, this._cy));
      bar.classList.add('barSvg');
    },

    /**
     * Update the container of all content at the center of the circle bars
     */
    _updateContentContainer: function() {
      var innerRadius = this._radius - this.barHeight / 2;
      var contentContainerStyle = this.$.contentContainer.style;
      contentContainerStyle.left = (this._cx - innerRadius) + 'px';
      contentContainerStyle.top = (this._cy - innerRadius) + 'px';
      contentContainerStyle.width = (innerRadius * 2) + 'px';
      contentContainerStyle.height = (innerRadius * 2) + 'px';
    },

    attached: function() {
      this._requestRender();
    }
  });
})();
</script>