<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="material-progress-behavior.html">
<

<!--
A Material design circle-multi-progress bar, inspired by Google Fit.

TODO docs

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--material-progress-bar-linecap` | Linecap of the bar(s). | `round`
`--material-progress-bars-background-color` | Background color behind the bar(s). | `rgba(0, 0, 0, 0.04)`
`--material-progress-background-color` | Background style of the content inside the cirle bar(s). | `transparent`
`--material-progress-content-style` | Mixin applied to the content inside the cirle bar(s). | `{}`


@group material-progress
@element material-progress-circle
@demo demo/index.html
-->
<dom-module id="material-progress-circle">
  <style>
    :host {
      position: relative;
      display: block;
      width: 200px;
      box-sizing: border-box;
      padding: 8px;
    }
    #container {
      position: relative;
      display: inline-block;
      width: 100%;
      padding-bottom: 100%;
      vertical-align: middle;
      opacity: 0;
      transition: opacity 375ms cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    #container.ready {
      opacity: 1;
    }
    svg {
      position: absolute;
      display: inline-block;
      left: 0; 
      right: 0;
    }
    .barsBackground {
      stroke: var(--material-progress-bars-background-color, rgba(0, 0, 0, 0.04));
    }
    .bar {
      stroke-linecap: var(--material-progress-bar-linecap, round);
    }
    :host([animated]) .barsBackground {
      transition: stroke-width 375ms cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    :host([animated]) .bar {
      transition: stroke-width 375ms cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    :host([animated]) #container.anim .bar {
      transition: stroke-dashoffset 375ms cubic-bezier(0.4, 0.0, 0.2, 1), transform 375ms cubic-bezier(0.4, 0.0, 0.2, 1), stroke-width 375ms cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    #contentContainer {
      position: absolute;
      border-radius: 50%;
      background: var(--material-progress-background-color, transparent);
      @apply(--layout-vertical);
      @apply(--layout-center-center);
      @apply(--material-progress-content-style);
    }
  </style>
  <template>
    <div id="container">
      <svg id="svg" version="1.1" xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" preserveAspectRatio="xMinYMin meet">
        <circle class="barsBackground"
            r$="[[_radius]]"
            cx$="[[_cx]]"
            cy$="[[_cy]]"
            fill="transparent"
            stroke-width$="[[barThickness]]" />
      </svg>
      <div id="contentContainer">
        <content></content>
      </div>
    </div>
  </template>
</dom-module>
<script>
(function() {
  'use strict';
  Polymer({
    is: 'material-progress-circle',

    properties: {
      /**
       * Data to display in the progress bar.
       * Each item describes a new progress bar, and must possess
       * a `value` and a `color` attribute.
       * 
       * Example:
       *
       *     {value: 20, color: '#FF5722'}
       */
      data: {
        type: Array,
        value: function() {
          return [];
        }
      },

      /**
       * Thickness of every progress bar.
       */
      barThickness: {
        type: Number,
        value: 12,
        observer: '_onResize'
      }
    },

    behaviors: [
      Polymer.MaterialProgressBehavior
    ],

    observers: [
      '_requestUpdate(data.*)'
    ],

    /**
     * Updates the component.
     */
    _doUpdate: function() {
      var _self = this;
      var barsData = JSON.parse(JSON.stringify(this.data || [])).reverse();
      var svg = Polymer.dom(this._getSVG());
      this._setSum(this._computeSum(barsData));
      this._cx = this._clientWidth / 2;
      this._cy = this._clientHeight / 2;
      var halfSize = Math.min(this._cx || this._cy, this._cy || this._cx);
      this._radius = Math.max(0, halfSize - this.barThickness / 2);
      this._dasharray = this._round(2 * Math.PI * this._radius);
      
      // Compute each bar's data
      var normalizedMax = Math.max(this.max, this.sum);
      barsData.reduceRight(function(currentSum, bar) {
        bar._angleOffset = (currentSum / normalizedMax) * 360;
        bar._dashOffset = _self._round((1 - bar.value / normalizedMax) * _self._dasharray
          + (currentSum == 0 ? _self.barThickness / 6.5 : 0)); // Fix first bar length
        return bar.value + currentSum;
      }, 0);

      // Ensure that there is a svg 'circle' element for each bar, flush the Dom and re-render
      if (barsData.length - (svg.children.length - 1) > 0) {
        this._createBars(barsData, 'circle');
        return;
      }

      // Set the correct attributes to each bar
      var svgChildren = svg.children;
      for (var i = 0, barCount = svgChildren.length; i < barCount-1; i++) {
        this._updateBar(svgChildren[i+1], barsData[i] || {});
      }

      // Set up the size of the inner content
      this._updateContentContainer(halfSize * 2);
    },

    /**
     * Pseudo getter for the inner container of all the SVGs.
     * Needed by `Polymer.MaterialProgressBehavior`
     */
    _getContainer: function() { return this.$.container; },

    /**
     * Pseudo getter for the SVG node that contains all tha bars.
     */
    _getSVG: function() { return this.$.svg; },

    /**
     * Update all necessary attributes of a bar (SVG circle node)
     */
    _updateBar: function(bar, descriptor) {
      var dashOffsetExists = descriptor._dashOffset || descriptor._dashOffset == 0;
      bar.setAttribute('r', this._radius);
      bar.setAttribute('cx', this._cx);
      bar.setAttribute('cy', this._cy);
      if (dashOffsetExists) {
        bar.setAttribute('stroke', descriptor.color || '#FF5722');
      }
      bar.setAttribute('fill', 'transparent');
      bar.setAttribute('stroke-width', this.barThickness);
      bar.setAttribute('stroke-dasharray', this._dasharray);
      bar.setAttribute('stroke-dashoffset', dashOffsetExists ? descriptor._dashOffset : this._dasharray);
      // IE and Edge can't handle CSS transform to SVG (and thus no animation)... Thanks MS!
      var rotation = (descriptor._angleOffset || 0) - 90;
      if (document.documentMode || /Edge\/\d./i.test(navigator.userAgent)) {
        bar.setAttribute('transform', 'rotate(' + rotation + ' ' + this._cx + ' ' + this._cy + ')');
      } else {
        bar.style.transform = 'rotateZ(' + rotation + 'deg)';
        bar.style.transformOrigin = this._cx + 'px ' + this._cy + 'px';
      }
    },

    /**
     * Update the container of all content at the center of the circle bars
     */
    _updateContentContainer: function(outerSize) {
      var style = this.$.contentContainer.style;
      style.top = this.barThickness + 'px';
      style.left = this.barThickness + 'px';
      // Using width and height instead of right and bottom in order to be responsive only when re-rendering
      style.width = (outerSize - 2 * this.barThickness) + 'px';
      style.height = (outerSize - 2 * this.barThickness) + 'px';
    }
  });
})();
</script>