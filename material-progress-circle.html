<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<

<!--
A Material design circle-multi-progress bar, inspired by Google Fit.

TODO docs

@group material-progress
@element material-progress-circle
@demo demo/index.html
-->
<dom-module id="material-progress-circle">
  <style>
    :host {
      position: relative;
      display: block;
      width: 200px;
      opacity: 0;
      transition: opacity 375ms cubic-bezier(0.4, 0.0, 0.2, 1);
      padding: 8px;
    }
    :host(.ready) {
      opacity: 1;
    }
    #container {
      position: relative;
      display: inline-block;
      width: 100%;
      padding-bottom: 100%;
      vertical-align: middle;
    }
    svg {
      position: absolute;
      display: inline-block;
      left: 0; 
      right: 0;
    }
    svg circle.backgroundCircle {
      stroke: var(--material-progress-bars-background-color, rgba(0, 0, 0, 0.04));
    }
    svg circle.bar {
      stroke-linecap: var(--material-progress-bar-linecap, round);
    }
    #container.animated svg circle.bar {
      transition: stroke-dashoffset 375ms cubic-bezier(0.4, 0.0, 0.2, 1);
    }
    #contentContainer {
      position: absolute;
      left: 0; 
      right: 0; 
      border-radius: 50%;
      background: var(--material-progress-background-color, transparent);
      @apply(--layout-vertical);
      @apply(--layout-center-center);
    }
  </style>
  <template>
    <div id="container" class$="[[_computeContainerClass(animated, _resizing)]]">
      <svg id="svg" version="1.1" width="100%" height="100%" preserveAspectRatio="xMinYMin meet">
        <circle class="backgroundCircle"
            r$="[[_radius]]"
            cx$="[[_cx]]"
            cy$="[[_cy]]"
            fill="transparent"
            stroke-width$="[[barThickness]]" />
      </svg>
      <div id="contentContainer">
        <content></content>
      </div>
    </div>
  </template>
</dom-module>
<script>
(function() {
  'use strict';
  Polymer({
    is: 'material-progress-circle',

    properties: {
      /**
       * Data to display in the progress bar.
       * Each item describes a new progress bar, and must possess
       * a `value` and a `color` attribute.
       * 
       * Example:
       *
       *     {value: 20, color: '#FF5722'}
       */
      data: {
        type: Array,
        value: function() {
          return [];
        }
      },

      /**
       * Maximum value for the `sum` of the bars' values.
       * 
       * If the `sum` is higher, it will be used as the `max`.
       */
      max: {
        type: Number,
        value: 100,
        observer: '_requestRender'
      },

      /**
       * Sum of all the bars' values.
       */
      sum: {
        type: Number,
        value: 0,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * Thickness of every progress bar.
       */
      barThickness: {
        type: Number,
        value: 12,
        observer: '_requestRender'
      },

      /**
       * Animate when the size of a bar changes.
       */
      animated: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    },

    behaviors: [
      Polymer.IronResizableBehavior
    ],

   observers: [
      '_requestRender(data.*)'
    ],

    listeners: {
      'iron-resize': '_onResize'
    },

    /**
     * Render the whole component
     */
    render: function() {
      Polymer.dom.flush();

      var _self = this;
      var barsData = JSON.parse(JSON.stringify(this.data || [])).reverse();
      var svg = Polymer.dom(this.$.svg);
      var container = this.$.container;
      this._setSum(this._computeSum(barsData));
      this._cx = container.clientWidth / 2;
      this._cy = container.clientHeight / 2;
      this._radius = Math.max(0, Math.min(this._cx || this._cy, this._cy || this._cx) - this.barThickness / 2);
      this._dasharray = 2 * Math.PI * this._radius;
      
      // Compute each bar's data
      var normalizedMax = Math.max(this.max, this.sum);
      barsData.reduceRight(function(currentSum, bar) {
        bar._sumValue = bar.value + currentSum;
        bar._dashoffset = (1 - bar._sumValue / normalizedMax) * _self._dasharray;
        return bar._sumValue;
      }, 0);

      // Ensure that there is a svg 'circle' element for each bar, flush the Dom and re-render
      if (barsData.length - (svg.children.length - 1) > 0) {
        this._createBars(barsData);
        return;
      }

      // Set the correct attributes to each bar
      var svgChildren = svg.children;
      var currentBar;
      for (var j = 0, barCount = svgChildren.length; j < barCount-1; j++) {
        currentBar = barsData[j] || {};
        this._updateBar(svgChildren[j+1], currentBar._dashoffset, currentBar.color);
      }

      // Set up the size of the inner content
      this._updateContentContainer();

      // Switch off the resizing flag
      this.async(function() {this._resizing = false;}, 500);

      // Display the element when ready
      this.classList.add('ready');
    },

    /**
     * Request a render when ready
     */
    _requestRender: function() {
      if (typeof this.$.container.clientWidth !== 'undefined')
        this.debounce('render', this.render, 100);
      else
        this.async(this._requestRender, 100);
    },

    _onResize: function() {
      this._resizing = true;
      this._requestRender();
    },

    /**
     * Create new bars in the DOM, then re-render
     */
    _createBars: function(barsData) {
      var svg = Polymer.dom(this.$.svg);

      // Add missing svg circle(s)
      var currentBar;
      var newCircle;
      for (var i = 0, barCountToAdd = barsData.length - (svg.children.length - 1); i < barCountToAdd; i++) {
        currentBar = barsData[i] || {};
        newCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        this._updateBar(newCircle, this._dasharray, currentBar.color);
        svg.appendChild(newCircle);
      }

      // Flush DOM and re-render to allow the css transition
      Polymer.dom.flush();
      this._requestRender();
    },

    /**
     * Compute the real sum off all the 'data.value'
     */
    _computeContainerClass: function(animated, resizing) {
      return animated && !resizing ? 'animated' : '';
    },

    /**
     * Transform attribute for every SVG circle
     */
    _computeTransform: function(cx, cy) {
      return 'rotate(-90, ' + cx + ', ' + cy + ')';
    },

    /**
     * Compute the real sum off all the 'data.value'
     */
    _computeSum: function(barsData) {
      return barsData.reduce(function(sum, bar) {
        return sum + (bar.value || 0);
      }, 0);
    },

    /**
     * Update all necessary attributes of a bar (SVG circle node)
     */
    _updateBar: function(bar, dashoffset, color) {
      var dashoffsetExists = dashoffset || dashoffset == 0;
      bar.setAttribute('r', this._radius);
      bar.setAttribute('cx', this._cx);
      bar.setAttribute('cy', this._cy);
      if (dashoffsetExists) {
        bar.setAttribute('stroke', color || '#FF5722');
      }
      bar.setAttribute('fill', 'transparent');
      bar.setAttribute('stroke-width', this.barThickness);
      bar.setAttribute('stroke-dasharray', this._dasharray);
      bar.setAttribute('stroke-dashoffset', dashoffsetExists ? dashoffset : this._dasharray);
      bar.setAttribute('transform', this._computeTransform(this._cx, this._cy));
      bar.classList.add('bar');
    },

    /**
     * Update the container of all content at the center of the circle bars
     */
    _updateContentContainer: function() {
      var innerRadius = this._radius - this.barThickness / 2;
      var contentContainerStyle = this.$.contentContainer.style;
      contentContainerStyle.left = (this._cx - innerRadius) + 'px';
      contentContainerStyle.top = (this._cy - innerRadius) + 'px';
      contentContainerStyle.width = (innerRadius * 2) + 'px';
      contentContainerStyle.height = (innerRadius * 2) + 'px';
    },

    attached: function() {
      this._requestRender();
    }
  });
})();
</script>